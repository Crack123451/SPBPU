clc, clear, echo off
gamma = 0.20;
delta = 0.10;
Pdov=0.95;
M=20;
T_obn = 0;
% определение абсцисс
Z_y = double(solve(sprintf('%f - 0.5 = 0.5 * erf(x/sqrt(2))', gamma)));
Z_inf = double(solve(sprintf('%f = erf(x/sqrt(2))', delta)));
 
% Процесс авторегресии первого порядка x(n) = a1*x(n-1)+g
% Процесс авторегресии второго порядка x(n) = a1*x(n-1)+a2*x(n-2)+g
a1=0.35;  % Коэффициент авторегресси a1
a2=0.5;  % Коэффициент авторегресси a2
A = [a1 a2; 1 0]; % Матрица состояния 
 
sigm = 1; % Дисперсия в канале возмущения
% Вычисляем дисперсию шума возмущения    
sigmx = sigm * sqrt( (1+a2)*((1-a2)^2-a1^2)/(1-a2) );
 
mu1 = 2; % МО шума возмущения
Msm = 0; % Постоянное смещение уровня шумов в канале измерения
Msv = 0; % постоянное смещение уровня шумов в канале возмущения
F = [1;0]; % Вектор входа по возмущению
    
% Параметры наблюдателя
C = [1 0]; % Вектор измерения по состоянию       
sigmy = 4; % Дисперсия шума измерения
%Начальные условия
X1 = [0;0]; % Начальное наблюдение
P = [1 0; 0 1]; % Корреляционная матрица ошибок фильтрации
X1_=[sigmx;0]; % Начальная оценка наблюдения
 
%Счетчик цикла реализаций (дискретное время)
n = 1000;  
n1 = 1000;  % при дефекте
Zi = zeros(1, n);
Zm = zeros(1, n);   % размер матрицы                       
%Цикл реализации работы фильтра
for i=1:n
    %Моделирование наблюдений
    if i < n1
        X1 = A*X1 + sigmx*(randn);
        Y = C*X1 + sigmy*(randn);
    else
        X1 = A*X1 + sigmx*(randn+Msv);
        Y = C*X1 + sigmy*6*(randn + Msm);
    end
    Xm(1,i) = X1(1,1);
    %Вычисление матричного коэффициента усиления
    %и корреляционной матрицы ошибок экстраполяции
    Q = A*P*A' + F*sigmx*F';
    K = Q*(C')*((C*Q*(C') + sigmy)^-1);
    P = Q - K*C*Q;
    %Оценка вектора состояния и вычисление обновляющей
    %последовательности
    X1_ = A*X1_ + F*mu1 + K*(Y - C*(A*X1_ + F*mu1));
    Z1 = Y - C*(A*X1_ + F*mu1);
    Zi(i) = Z1;
    %нормировочный коэффициент
    S = sigmy + C*P*(C') - sigmy*(K')*(C') - C*K*sigmy;
    %нормируем обновляющую последовательность
    Z = (Z1)*(S^-0.5);
    Zm(1,i)=Z;
   
    % Вычисляем автокорреляционную функцию
    r = covf2(Zm',10);
 
    %интервальный метод
    if i<=M
        n=i;
    else
        n=M;  
    end
    mn=mean(Zm(1,i-n+1:i));
    Sn=std(Zm(1,i-n+1:i));
    % находим толерантный множитель Kn
    Kn = Z_inf * (1 + (Z_y / sqrt(2 * n)) + (5 * Z_y ^ 2 + 10) / (12 * n));
    if i<=M
        l1(i)=mn-Kn*Sn;
        l2(i)=mn+Kn*Sn;
    else
        l1(i)=l1(i-1);
        l2(i)=l2(i-1);
    end
    if (n>2)
        % находим квантили Стьюдента
        t_st=tinv(1-(1-Pdov)/2,n-1);
        % строим u1 и u2
        u1(i)=mn-t_st*Sn/sqrt(n);
        u2(i)=mn+t_st*Sn/sqrt(n);
      % решение о наличии дефекта
        if (l1(i)>u2(i)||l2(i)<u1(i))
            err_int(i)=1;
        else
            err_int(i)=0;
            if T_obn == 0
                T_obn = i;
            end
        end
    end
end
Plo=mean(err_int)
T_obn
    figure('color', 'white')
    hold on   
    subplot(3,1,1);
    plot(Zi,'r');
    grid;
    xlabel('t');
    ylabel('Z');
    set(gca,'FontName','Arial Cyr');
    title('Обновляющий процесс');
    
    subplot(3,1,2);
    plot(Zm,'b');
    grid;
    xlabel('t');
    ylabel('Zn');
    set(gca,'FontName','Arial Cyr');
    title('Нормализованный обновляющий процесс');
 
        subplot(3,1,3);
    plot(r,'g');
    grid;
    xlabel('t');
    ylabel('r');
    set(gca,'FontName','Arial Cyr');
    title('Корреляционная функция');
 
    
figure('color', 'white')
hold on
grid on
plot(u1)
plot(u2)
plot(l1, 'r')
plot(l2, 'r')
